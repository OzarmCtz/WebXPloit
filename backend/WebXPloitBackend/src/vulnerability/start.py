# cython: language_level=3


from concurrent.futures import ProcessPoolExecutor, ThreadPoolExecutor, as_completed
import threading

from fastapi import concurrency
from config.params import ConfigConst


from src.vulnerability.disclosure.env.env_path import ExploitEnvVuln
from src.vulnerability.disclosure.aws.aws_path import ExploitAwsVuln
from src.vulnerability.disclosure.yii.yii_path import ExploitYiiVuln
from src.vulnerability.disclosure.php.phpinfo_path import ExploitPhpInfoVuln
from src.vulnerability.disclosure.git.git_path import ExploitGitVuln
from src.vulnerability.cve.joomla.CVE_2023_23752.joomla_db_exploit import (
    JoomlaCveDBUnder428,
)

import src.utils.generics.generic as UtilsGenerics

from src.utils.specifics.check_host_before_vuln import CheckHostBeforeVuln

from src.utils.specifics.specific import format_url


class StartProcessVuln:
    def __init__(self):
        self.DTB_DOMAIN = ConfigConst.DatabasePathConfig.DOMAIN_PATH
        self.IP_LIST_RANGED_FOR_IP = (
            ConfigConst.DatabasePathConfig.IP_LIST_RANGED_FOR_IP
        )
        self.THREAD_VULN = ConfigConst.LaunchConfig.THREADS_CHEK_VULNS
        self.notifier = UtilsGenerics.TelegramNotifier()
        self.logger = UtilsGenerics.setup_logging(
            logger_name=f"{ConfigConst.LoggingConfig.LOGGER_OUTPUT_NAME}",
            log_file=ConfigConst.LoggingConfig.OUTPUT_FILE_PATH,
        )
        self.logger_vuln = UtilsGenerics.setup_logging(
            logger_name=f"{ConfigConst.LoggingConfig.LOGGER_VULN_NAME}",
            log_file=ConfigConst.LoggingConfig.VULN_LOG_FILE_PATH,
        )

        self.file_lock = threading.Lock()

        self.DOMAIN = ConfigConst.LaunchConfig.DOMAIN
        self.IP = ConfigConst.LaunchConfig.IP

        vulnerabilities = {
            "vuln_env": ExploitEnvVuln,
            "vuln_git": ExploitGitVuln,
            "vuln_aws": ExploitAwsVuln,
            "vuln_yii": ExploitYiiVuln,
            "phpinfo": ExploitPhpInfoVuln,
            "CVE_2023_23752": JoomlaCveDBUnder428,
        }

        self.exploit_vulns = {vuln_name: vuln_class() for vuln_name, vuln_class in vulnerabilities.items()}


        self.check_before_vuln = CheckHostBeforeVuln()

    def run(self):
        try:
            url = []
            if self.DOMAIN:
                with open(self.DTB_DOMAIN, "r") as domain_file:
                    for line in domain_file:
                        url.append(line.strip())
            if self.IP:
                with open(self.IP_LIST_RANGED_FOR_IP, "r") as ip_file:
                    for line in ip_file:
                        url.append(line.strip())
            self.logger.info(f"StartProcessVuln : exploit {len(url)} url Started ...")
            print(
                f"[{UtilsGenerics.ret_hour()}] StartProcessVuln : exploit {len(url)} url Started .. "
            )

            with ThreadPoolExecutor(max_workers=self.THREAD_VULN) as executor:
                futures = [
                    executor.submit(self.vulnList, single_url) for single_url in url
                ]
                concurrency.futures.wait(futures)

            print(
                f"[{UtilsGenerics.ret_hour()}] StartProcessVuln : exploit {len(url)} url Finished . "
            )

            self.logger.info(f"StartProcessVuln : exploit {len(url)} url Finished .")
            return
        except Exception as e:
            self.logger.error(f"An error occurred in the `run` method: {e}")

    def vulnList(self, url):
        url_controlled = format_url(url)
        try:
            sessions, is_founded = self.check_before_vuln.run(url_controlled)
            if is_founded:
                self.logger_vuln.info(f"{url_controlled} [SUCCESS CheckHostBeforeVuln]")
                return

            if sessions is not None:
                return self.perform_vuln_checks(url_controlled, sessions)
            else:
                self.log_failure(url_controlled)
        except Exception as e:
            self.log_exception("vulnList", e, url_controlled)

    def perform_vuln_checks(self, url_controlled, sessions):

        exceptions = []
        for vuln_name, vuln_class in self.exploit_vulns.items():
            if vuln_class:
                try:
                    vuln_result = vuln_class.run(url_controlled, sessions)
                    if vuln_result:
                        self.logger_vuln.info(f"{url_controlled} [SUCCESS]")
                        return
                except Exception as e:
                    exceptions.append((f"{vuln_class}", e, url_controlled))
                    return
        self.log_failure(url_controlled)


        for exception in exceptions:
            self.log_exception(*exception)

    def log_exception(self, context, exception, url):
        self.logger_vuln.error(
            f"{context} / error occurred: {exception} / with url : {url}"
        )

    def log_failure(self, url):
        self.logger_vuln.info(f"{url} [FAILED]")
